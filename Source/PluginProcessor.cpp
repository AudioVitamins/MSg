/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"


//==============================================================================
AudioVitaminsAudioProcessor::AudioVitaminsAudioProcessor()
{
	dryLatency=0;
	isPlaying = false;
    currentBar=0;
    currentBeat=0;
    lastBar=0;
    isInBarLoop = false;
    barCounter = 0;
    lastBarTick = 0; // hold last bar that swichted autions
    lastAuditionedSlot = 0;
	barLength = 0; // default to 0
    timerCounter=0;
    auditionAcc=0;
	numActive=0;

    
    PropertiesFile::Options options;
    options.applicationName     = "AudioVitaminsMSG";
    options.filenameSuffix      = "settings";
    options.osxLibrarySubFolder = "Preferences"; // check the correct directory
        
    gAppProperties = new ApplicationProperties();
    gAppProperties->setStorageParameters (options);
    
    knownPluginList = new juce::KnownPluginList;
    
    deadMansPedalFile = gAppProperties->getUserSettings()->getFile().getSiblingFile ("RecentlyCrashedPluginsList");
    
    fPluginManager.addDefaultFormats();
    
    ScopedPointer<XmlElement> pluginList(gAppProperties->getUserSettings()->getXmlValue("pluginList"));
    if (nullptr != pluginList)
    {
        knownPluginList->recreateFromXml(*pluginList);
    }
    else knownPluginList->createXml();
    
    knownPluginList->addChangeListener(this);
    pluginSortMethod = (KnownPluginList::SortMethod)gAppProperties->getUserSettings()->getIntValue ("pluginSortMethod", KnownPluginList::sortByManufacturer);
    knownPluginList->sort(pluginSortMethod, true);
    
    for (int i = 0; i < 2; i++)
    {
        pluginAssignProcessor[i]    = new PluginAssignProcessor(fPluginManager, knownPluginList, this, i);
        activeSlot[i]               = false;
        shouldAudition[i]           = false;
        audition[i]                 = false;
        slot_latency[i]             = 0;
    }
    
    barLength = 1;
    
    // create slot parameter list under the hood !
//    for (int i = 0; i < TOTAL_SLOT_PARAMS * 2; i++)
//    {
//        SlotAudioParameter * param = new SlotAudioParameter();
//        param->setValue(0.0);
//        addParameter(param);
//    }
//    
//    // create gui parameters
//    for (int i = 0; i < 6; i++)
//    {
//        SlotAudioParameter * param = new SlotAudioParameter();
//        param->setValue(0.0);
//        addParameter(param);
//    }
    
    
    
    for (int i = 0; i < END_PARAMS; i++)
    {
       // SlotAudioParameter * param = new SlotAudioParameter();
       // param->setValue(0.0);
       // addParameter(param);
        
        params[i] = 0.f;
        
    }
    
    params[WETDRY_MID] = 100.0;
    params[WETDRY_SIDE] = 100.0;
 
    
    // create vu v
    for (int i = 0; i < 8; i++) {
        vuValue[i] = 0.f;
    }
    
    inputGainMid         = 1.f;
    inputGainSide        = 1.f;
    outputGainMid        = 1.f;
    outputGainSide       = 1.f;
    wetdryMid            = 0.5;
    wetdrySide           = 0.5;
    
    delay[0] = new Delay(44100);
    delay[1] = new Delay(44100);
}

AudioVitaminsAudioProcessor::~AudioVitaminsAudioProcessor()
{
    gAppProperties->closeFiles();
	gAppProperties =  nullptr;
	knownPluginList = nullptr;
	pluginAssignProcessor[0]  = nullptr;
	pluginAssignProcessor[1]  = nullptr;
}

void AudioVitaminsAudioProcessor::changeListenerCallback (ChangeBroadcaster*)
{
    // menuItemsChanged();
    
    // save the plugin list every time it gets changed, so that if we're scanning
    // and it crashes, we've still saved the previous ones
    ScopedPointer<XmlElement> savedPluginList (knownPluginList->createXml());
    
    if (savedPluginList != nullptr)
    {
        PropertiesFile*userSettings = gAppProperties->getUserSettings();
        
        userSettings->setValue ("pluginList", savedPluginList);
        gAppProperties->saveIfNeeded();
    }
}

void AudioVitaminsAudioProcessor::rescanPlugins()
{
    // need to call this from GUI thread, so set it in MainViewComponent.
    // rescan plugin dir for new or all plugins
    for (int i = 0; i < fPluginManager.getNumFormats(); ++i)
    {
        AudioPluginFormat* const format = fPluginManager.getFormat (i);
        
        if (format->canScanForPlugins())
        {
            
        }
            //menu.addItem (10 + i, "Scan for new or updated " + format->getName() + " plug-ins");
    }
}

//==============================================================================
const String AudioVitaminsAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

/*
int AudioVitaminsAudioProcessor::getNumParameters()
{
    return 0;
}
 */

#define AAX 1

float AudioVitaminsAudioProcessor::getParameter (int index)
{
    float val = 0;
    
    if (index >= 0 && index < TOTAL_SLOT_PARAMS)
    {
        int paramIndex = index - (TOTAL_SLOT_PARAMS * 0);
        if (paramIndex == SLOT_ACTIVE || paramIndex == SLOT_PLUGINREF || paramIndex == SLOT_LOADED)
        {
            return params[index];
            //return AudioProcessor::getParameter(index);
        }
        else
        {
            val = pluginAssignProcessor[0]->getParameter(paramIndex);
            params[index] = val;
            return params[index];
            //return pluginAssignProcessor[0]->getParameter(paramIndex);
        }
    }
    else if ( (index >= TOTAL_SLOT_PARAMS * 1) && index < ( TOTAL_SLOT_PARAMS * 2 ) )
    {
        int paramIndex = index - (TOTAL_SLOT_PARAMS * 1);
        if (paramIndex == SLOT_ACTIVE || paramIndex == SLOT_PLUGINREF || paramIndex == SLOT_LOADED)
        {
            return params[index];
            //return AudioProcessor::getParameter(index);
        }
        else
        {
            val = pluginAssignProcessor[1]->getParameter(paramIndex);
            params[index] = val;
            return params[index];
            //return pluginAssignProcessor[1]->getParameter(paramIndex);
        }
    }
    else if (index >= ( TOTAL_SLOT_PARAMS * 2) )
    {
        return params[index];
        //return AudioProcessor::getParameter(index);
    }
    else
    {
        return 0;
    }
}


void AudioVitaminsAudioProcessor::setParameter (int index, float newValue)
{
    //AudioProcessor::setParameter(index, newValue);  //*** EDIT FOR PT.. Reomment for AU/VST
    params[index] = newValue;

    if (index >= 0 &&  index < TOTAL_SLOT_PARAMS)
    {
        // slot 0
        int paramIndex = index;
        
        if (paramIndex == SLOT_ACTIVE) {
            activeSlot[0] = (bool)newValue;
        }
        
        pluginAssignProcessor[0]->setParameter(paramIndex, newValue);
    }
    else if ( (index >= TOTAL_SLOT_PARAMS) && index < ( TOTAL_SLOT_PARAMS * 2 ) )
    {
        // slot 1
        int paramIndex = index - (TOTAL_SLOT_PARAMS * 1);
        
        if (paramIndex == SLOT_ACTIVE) {
            activeSlot[1] = (bool)newValue;
        }
        
        pluginAssignProcessor[1]->setParameter(paramIndex, newValue);
    }
    else if (index >= (TOTAL_SLOT_PARAMS * 2))
    {
       // AudioProcessor::setParameter(index, newValue);

        if (index == INPUTGAIN_MID)
        {
            inputGainMid = pow(10.0, newValue * 0.05);
        }
        else if (index == INPUTGAIN_SIDE)
        {
            inputGainSide = pow(10.0, newValue * 0.05);
        }
        else if (index == OUTPUTGAIN_MID)
        {
            outputGainMid = pow(10.0, newValue * 0.05);
        }
        else if (index == OUTPUTGAIN_SIDE)
        {
            outputGainSide = pow(10.0, newValue * 0.05);
        }
        else if (index == WETDRY_MID)
        {
            wetdryMid = newValue * 0.01;
        }
        else if (index == WETDRY_SIDE)
        {
            wetdrySide = newValue * 0.01;
        }
    }
}

void AudioVitaminsAudioProcessor::runLatencyTest()
{
    suspendProcessing(true);
    
    int buffersize = getSampleRate(); // gets 1 second of buffer to test latency
    
    // need to call preparetoplay with extended blocksize to check longer latency
    this->prepareToPlay(getSampleRate(), buffersize);
    
    int maxLatency = 0;
    for (int i = 0; i < 2; i++)
    {
        if (activeSlot[i])
        {
            slot_latency[i] = pluginAssignProcessor[i]->getLatencySamples();
            printf("getLatency %i = %i", i, slot_latency[i]);
            
            if (slot_latency[i] >= maxLatency) {
                maxLatency = slot_latency[i];
            }
        }
    }
    
    // need to set latency to delay times for slots
    for (int i = 0; i < 2; i++) {
        pluginAssignProcessor[i]->setDelayCompensation(maxLatency-slot_latency[i]);
    }
    
    dryLatency = maxLatency-slot_latency[0];
    
    
    // need to set Max Latency to Plugin to synchronise Host.
    this->setLatencySamples(maxLatency);
    
    // prepare to play
    this->prepareToPlay(getSampleRate(), getBlockSize());
    
    // activate processing
    suspendProcessing(false);
}

void AudioVitaminsAudioProcessor::setParameterNotifyingHost (int parameterIndex, float newValue)
{
    AudioProcessor::setParameter(parameterIndex, newValue);
}

bool AudioVitaminsAudioProcessor::isParameterAutomatable (int parameterIndex) // removed const in case of bug
{
    return AudioProcessor::isParameterAutomatable(parameterIndex);
}

const String AudioVitaminsAudioProcessor::getParameterName (int index)
{
    return String();
}

const String AudioVitaminsAudioProcessor::getParameterText (int index)
{
    return String();
}

const String AudioVitaminsAudioProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String AudioVitaminsAudioProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool AudioVitaminsAudioProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool AudioVitaminsAudioProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool AudioVitaminsAudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool AudioVitaminsAudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool AudioVitaminsAudioProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double AudioVitaminsAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int AudioVitaminsAudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int AudioVitaminsAudioProcessor::getCurrentProgram()
{
    return 0;
}

void AudioVitaminsAudioProcessor::setCurrentProgram (int index)
{
}

const String AudioVitaminsAudioProcessor::getProgramName (int index)
{
    return String();
}

void AudioVitaminsAudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void AudioVitaminsAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    for (int i = 0; i<2; i++)
    {
        pluginAssignProcessor[i]->setPlayConfigDetails(getNumInputChannels(), getNumOutputChannels(), sampleRate, samplesPerBlock);
        pluginAssignProcessor[i]->prepareToPlay(sampleRate, samplesPerBlock);
    } 
}

void AudioVitaminsAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    for (int i = 0; i < 2; i++)
    {
         pluginAssignProcessor[i]->releaseResources();
    }
    // spare memory, etc.
}


void AudioVitaminsAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
   
    
    // Input VU -- will need to add latency adjustment to this..
    // ===========================================================================
    for (int channel = 0; channel < getNumInputChannels(); ++channel)
    {
        vuValue[channel] = buffer.getMagnitude(channel, 0, buffer.getNumSamples());
        //vuValue[channel] = tempBuffer.getMagnitude(channel, 0, buffer.getNumSamples());
    }
    // ===========================================================================

    // DRY buffer
    
    // Sum input 1 & 2 for Mid buffer
    AudioSampleBuffer midSumBuffer;
    midSumBuffer.setSize(1, buffer.getNumSamples());
    midSumBuffer.clear();
    midSumBuffer.addFrom(0, 0, buffer, 0, 0, buffer.getNumSamples());
    midSumBuffer.addFrom(0, 0, buffer, 1, 0, buffer.getNumSamples());
    //midSumBuffer.addFrom(0, 0, tempBuffer, 0, 0, buffer.getNumSamples());
    //midSumBuffer.addFrom(0, 0, tempBuffer, 1, 0, buffer.getNumSamples());
    
    
    
    // multiply Mid buffer by 0.5 + mid input gain
    float mid_gain = inputGainMid * 0.5;
    midSumBuffer.applyGain(mid_gain);
    
    
    // Sum input 1 & 2 for Side buffer with phase invert for channel 2
    AudioSampleBuffer sideSumBuffer;
    sideSumBuffer.setSize(1, buffer.getNumSamples());
    sideSumBuffer.clear();
    sideSumBuffer.addFrom(0, 0, buffer, 0, 0, buffer.getNumSamples());
    //sideSumBuffer.addFrom(0, 0, tempBuffer, 0, 0, buffer.getNumSamples());
    
    
    
    // phase invert channel 2
	
    float * buf = (float *)buffer.getReadPointer (1);
    for (int i = 0; i < buffer.getNumSamples(); i++) { buf[i]*= -1; }
    sideSumBuffer.addFrom(0, 0, buf, buffer.getNumSamples());
	

	//float * buf = (float *)buffer.getReadPointer (1);
	//float buf[buffer.getNumSamples()];
    //for (int i = 0; i < buffer.getNumSamples(); i++) 
	//{ 
	//	buf[i]*= -1; 
	//}
    //sideSumBuffer.addFrom(0, 0, buf, buffer.getNumSamples());
    
    // multiply side buffer by 0.5 + mid input gain
    float side_gain = inputGainSide * 0.5;
    sideSumBuffer.applyGain(side_gain);
    
    // do meters for mid/side
    vuValue[2] = midSumBuffer.getMagnitude(0, 0, midSumBuffer.getNumSamples());
    vuValue[3] = sideSumBuffer.getMagnitude(0, 0, sideSumBuffer.getNumSamples());

    
     
    
    // WET buffer & PLUGIN processing
    
    // MID
    AudioSampleBuffer midWetBuffer;
    midWetBuffer.setSize(2, buffer.getNumSamples());
    midWetBuffer.clear();
    // copy dry buffer to wet buffer before processing
    midWetBuffer.copyFrom(0, 0, midSumBuffer, 0, 0, buffer.getNumSamples());
    midWetBuffer.copyFrom(1, 0, midSumBuffer, 0, 0, buffer.getNumSamples());
    
    // process plugin
    pluginAssignProcessor[0]->processBlock(midWetBuffer, midiMessages);
    
    
    
    // SIDE
    AudioSampleBuffer sideWetBuffer;
    sideWetBuffer.setSize(2, buffer.getNumSamples());
    sideWetBuffer.clear();
    // copy dry buffer to wet buffer before processing
    sideWetBuffer.copyFrom(0, 0, sideSumBuffer, 0, 0, buffer.getNumSamples());
    sideWetBuffer.copyFrom(1, 0, sideSumBuffer, 0, 0, buffer.getNumSamples());
    
    // process plugin
    pluginAssignProcessor[1]->processBlock(sideWetBuffer, midiMessages);
    
    
    
     

    // do meters for mid/side
    // temp buffer for vu calculation
    AudioSampleBuffer midOutputVUBuffer;
    midOutputVUBuffer.setSize(1, buffer.getNumSamples());
    midOutputVUBuffer.clear();
    midOutputVUBuffer.copyFrom(0, 0, midWetBuffer, 0, 0, buffer.getNumSamples());
    midOutputVUBuffer.applyGain(outputGainMid);
    vuValue[6] = midOutputVUBuffer.getMagnitude(0, 0, midOutputVUBuffer.getNumSamples());
    
    
    AudioSampleBuffer sideOutputVUBuffer;
    sideOutputVUBuffer.setSize(1, buffer.getNumSamples());
    sideOutputVUBuffer.clear();
    sideOutputVUBuffer.copyFrom(0, 0, sideWetBuffer, 0, 0, buffer.getNumSamples());
    sideOutputVUBuffer.applyGain(outputGainSide);
    vuValue[7] = sideOutputVUBuffer.getMagnitude(0, 0, sideOutputVUBuffer.getNumSamples());
    
    
    
     

    // dry wet mix
    float outputMid, outputSide, outputLeft, outputRight = 0.f;
    
  //  float * mainBufLeft = buffer.getWritePointer(0);
  //  float * mainBufRight= buffer.getWritePointer(1);
    
    
    // add initial buffer to delay class
    AudioSampleBuffer midSumDryBuffer;
    midSumDryBuffer.setSize(1, buffer.getNumSamples());
    midSumDryBuffer.clear();
    
    
    
    
    {
        if (slot_latency[0] > 0)
        {
            //float * data = midSumBuffer.getWritePointer(0);
            for (int i = 0; i < buffer.getNumSamples(); i++)
            {
               float sample = midSumBuffer.getSample(0, i);
                //delay[0]->Process(&data[i]);
                delay[0]->Process(&sample);
                
                midSumDryBuffer.setSample(0, i , delay[0]->GetDelayedSample( slot_latency[0]));
            }
        }
        else
        {
            midSumDryBuffer.addFrom(0, 0, midSumBuffer, 0, 0, buffer.getNumSamples());
        }
        
    }
	
     
    
    
    
    
    // add initial buffer to delay class
    AudioSampleBuffer sideSumDryBuffer;
    sideSumDryBuffer.setSize(1, buffer.getNumSamples());
    sideSumDryBuffer.clear();
    
    
    
    {
        // *** at 0 latency, fucks it up.. need to override dry delay when its at 0 latency...
        if (slot_latency[1] > 0)
        {
            //float * data = sideSumBuffer.getWritePointer(0);
            for (int i = 0; i < buffer.getNumSamples(); i++)
            {
                float sample = sideSumBuffer.getSample(0, i);
                //delay[1]->Process(&data[i]);
                delay[1]->Process(&sample);
                
                sideSumDryBuffer.setSample(0, i , delay[1]->GetDelayedSample( slot_latency[0] ));
            }
        }
        else
        {
            sideSumDryBuffer.addFrom(0, 0, sideSumBuffer, 0, 0, buffer.getNumSamples());
        }
        
    }
     
    
    
    // Changes ////
    // 1. All float * pointers to to write pointers, might be dangling !!
    //
    
    for (int i = 0; i < buffer.getNumSamples(); i++)
    {
        outputMid       = (wetdryMid * midWetBuffer.getSample(0, i)) + ((1.0 - wetdryMid) * midSumDryBuffer.getSample(0, i));
        outputSide      = (wetdrySide * sideWetBuffer.getSample(0, i)) + ((1.0 - wetdrySide) * sideSumDryBuffer.getSample(0, i));
        
        outputLeft      = (outputMid * outputGainMid) + (outputSide * outputGainSide);
        outputRight     = (outputMid * outputGainMid) + ((outputSide * outputGainSide) * -1);
        
       // mainBufLeft[i]  = outputLeft;
       // mainBufRight[i] = outputRight;
        
        
        buffer.copyFrom(0, i, &outputLeft, 1);
        buffer.copyFrom(1, i, &outputRight, 1);
        
    }
  
 
    // Output VU
    // ===========================================================================
    for (int channel = 0; channel < getNumInputChannels(); ++channel)
    {
        vuValue[channel + 4] = buffer.getMagnitude(channel, 0, buffer.getNumSamples());
    }
    // ===========================================================================
     
    
    
}

//==============================================================================
bool AudioVitaminsAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* AudioVitaminsAudioProcessor::createEditor()
{
    return new AudioVitaminsAudioProcessorEditor (*this);
}

//==============================================================================
void AudioVitaminsAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    XmlElement xml ("AudioVitaminsMSgPluginSettings");
    
    for (int i = 0; i < END_PARAMS; i++)
    {
        String att(i);
        
        float lastValue = this->getParameter(i);
        
        xml.setAttribute(att, lastValue);
    }
    
    copyXmlToBinary (xml, destData);
}

void AudioVitaminsAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    ScopedPointer<XmlElement> xmlState (getXmlFromBinary (data, sizeInBytes));
    
    if (xmlState != nullptr)
    {
        if (xmlState->hasTagName ("AudioVitaminsMSgPluginSettings"))
        {
            for (int i = 0; i < END_PARAMS; i++)
            {
                String att(i);
                float newValue = (float)xmlState->getDoubleAttribute( att );

                this->setParameter(i, newValue);
                //setParameter(i, newValue);
                
                //printf("param %i : val : %f ",i, getParameter(i));
            }
        }
    }
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new AudioVitaminsAudioProcessor();
}


